# 2025-12-17 TIL

## DI 의존성 주입

### 개념
- 의존성 주입은 객체가 자신의 의존성을 직접 생성하지 않고 외부엥서 제공받는 소프트웨어 디자인 패턴

### 의존성 역전 원칙 (DIP)
- DIP의 핵심
  - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 되며, 추상화에 의존해야 한다.
  - 추상화는 구체적인 구현 세부 사항에 의존해서는 안 된다.
- 기대 효과
  - ViewModel의 구체적인 RepositoryImpl 클래스가 아닌, 인터페이스에 의존하게 되어 결합도가 낮아진다.
  - 쉽게 다른 구현체로 교체할 수 있고 테스트가 용이해 진다.

### 의존성 주입의 장점
- 테스트 용이성 : 모의 객체를 주입해 단위 테스트 가능
- 유연성 : 동일한 인터페이스를 구현한 다양한 구현체로 쉽게 교체 가능
- 결합도 감소 : 컴포넌트 간 직접적인 의존성 제거
- 관심사 분리 : 객체 생성과 사용의 책임 분리

### 의존성 등록 방식 차이
- Singleton
  - 앱 시작시 1번만 생성
  - 예시 : Repository, DataSource, UseCase
- Factory
  - 필요할 때마다 새로 생성
  - 예시 : ViewModel

### ViewModel 은 왜 Factory?
- 상태가 화면마다 다르기 때문에
  - ViewModel은 화면 상태를 관리
  - 각 화면마다 독립된 상태 필요
- 의도하지 않은 상태 공유 방지
  - Singleton으로 만들면 앱 전체에서 하나의 ViewModel만 사용
  - 상태가 섞이거나 꼬일 수 있다.
  - A 화면에서 값이 바뀌면 B 화면에도 반영되어 버그 발생

### Repository 는 왜 Singleton?
- 대부분 상태를 갖지 않는 기능 클래스이기 때문
- 같은 기능은 계속 재사용하면 효율적
- 메모리도 아끼고, 빠르고 안정적

### Top-Level 에 싱글톤 객체 정의하지 않는 이유
- 기술적으로는 가능하지만, 권장되지 않는다.
- 한 번만 생성되어 전역적으로 사용되지만 의존성 등록 / 해제가 어렵고 유연성이 떨어진다.
- 테스트 어려움
- 의존성 관계 고정
- 초기화 시점 조절 불가


### Android 의존성 주입 라이브러리
- Hilt
  - 컴파일 안전
  - Google 주도
  - 매직이 많음
  - KMP 대응
  - 취업하려면 써야 함
- Koin
  - 코틀린 전용 - 런타임 주입
  - 직관적
  - 근본에 가깝다.
  - KMP 대응

### Dagger - Hilt
- Google 공식 의존성 주입 라이브러리
- Java 베이스고 Android 전용이었는데 최근 KMP 지원

### Koin
- 서비스 로케이터 패턴 제공
- Kotlin 베이스고 가장 쉽고, 플랫폼에 구애받지 않고, 직관적

### 서비스 로케이터 패턴
- 객체의 생성과 의존성을 중앙에서 관리하는 디자인 패턴
- 서비스 로케이터 : 다양한 서비스(객체)를 등록하고 클라이언트가 필요할 때 해당 서비스 반환
- 장점 : 유연성과 중앙 집중화로 코드 일관성 유지

## Koin
```kotlin
startKoin {
    androidLogger() // koin 주입할 때 Log 나오게 하는 옵션 (없어도 된다.)
    androidContext(this@AppApplication) //data layer에 context가 필요할 때 굉장히 쉽게 전달 가능하게 해줌.
    modules(
        appModule,
        datasourceModule,
        repositoryModule,
        useCaseModule,
        viewModelModule
    )
}
// single<Interface> { 구현체 } 형태로 사용
// get() -> dataSource 등록 한거를 알아서 가져다 쓴다.
single<ProcedureRepository> { ProcedureRepositoryImpl(get()) }
viewModel { SavedRecipesViewModel(getSavedRecipesUseCase = get()) }

//.....
HomeScreenRoot(viewModel: HomeViewModel = koinViewModel())
```
- single : 하나의 인스턴스만 존재
- factory: 매번 새로운 인스턴스 생성
- viewModel : Android 뷰모델 주입용
- androidContext: 컨텍스트 주입용

- get<얻을 타입>() 으로 어디서든 객체로 등록된 객체를 주입 받을 수 있음
- koinViewModel()로 주입!

### 의존성 주입의 원칙
- 서비스 로케이터가 안티 패턴으로 비판 받는 이유
  - 클래스 내부에서 직접 서비스 로케이터를 통해 의존성을 가져옴
  - 클래스의 의존성을 숨겨 코드를 이해하기 어렵게 함
  - 테스트 시 Mock 객체로 대체하기 어렵다
- 서비스 로케이터를 잘 사용하는 방법
  - 의존성 구성은 앱의 진입점(Application), 라우팅 설정 등 앱의 최상단에서 관리한다.
  - ViewModel, Repository 등 주요 클래스에서 get()을 직접 호출하지 말고, 생성자를 통해 의존성을 주입받는 것을 원칙으로 한다
