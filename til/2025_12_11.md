# 2025-12-11 TIL

## 고급 상태관리 기법

### 문제점
```kotlin
@Composable
fun CounterScreen(
    modifier: Modifier = Modifier,
    viewModel: CounterViewModel = viewModel(),
)
```
- Screen 이 ViewModel에 직접 의존
- UI 테스트와 Preview 작성 어려움
- 테스트 작성 시간 증가
- 재사용성 낮음
- 컴포넌트 수준 테스트만 가능 -> 화면 단위 테스트 불가

### 솔루션
- 외부 의존성을 Screen 에서 분리
- Screen을 순수 UI 로 유지
- 테스트 가능, 재사용성 향상

### Screen 에서 하면 안되는 것
- ViewModel 인스턴스 접근
- Repository 직접 호출
- 화면 이동
- 비즈니스 로직 포함
- Screen은 상태와 콜백만 가져야 한다.
```kotlin
fun SearchRecipeScreen(
    state: SearchState,
    onQueryChange: (String) -> Unit
) {
    RecipeList(recipes = state.filteredRecipes)
    
    SearchBar(onQueryChange = onQueryChange)
}
```

### Root
- Screen 을 감싸는 외부 래퍼 역할을 하는 Root
```kotlin
fun SearchRecipeScreenRoot(
    viewModel: SearchViewModel = viewModel()
) {
    val state by viewModel.state.collectAsState()
    
    SearchRecipeScreen(
        state = state,
        onQueryChange = viewModel::onQueryChange
    )
}
```
- ViewModel 주입
- 상태 구독
- 화면 이동
- 등의 외부 의존 처리 담당

- Root 는 테스트에서 제외
- 순수한 UI 만 테스트
- Root와 ViewModel 의 상호작용은 필요에 따라 별도의 통합 테스트로 검증

### Root가 가져갈 책임
- ViewModel 의존성 주입
- State 구독하여 Screen 전달
- 화면 이동 처리
- Dialog / Snackbar 등 1회성 이벤트 처리
- Lifecycle + remember 등 초기화 처리
- 권한 요청 등 외부 시스템 연결
- Preview or UI 테스트를 방해하는 모든 로직 이동

## 정리
- Screen 은 상태 + 콜백 만 가진 순수UI
- Root 는 ViewModel, Navigation, 권한, 이벤트 등 외부 의존성 책임
- 테스트 용이성 극대화
- Preview 활용 극대화
- 상태관리 라이브러리 교체 비용 최소화
- UI 작성의 일관성 유지
