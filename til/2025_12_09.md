# 2025-12-05 TIL

## MVVM 패턴

### 아키텍처 디자인 패턴
- 소프트웨어를 작성함에 있어 코드 뿐 아니라 전체적인 구조(Architecture)에 대한 좋은 패턴도 존재
- 대중적인 패턴
  - MVC
  - MVC2
  - MVP
  - MVVM
  - MVI
- 위 패턴들은 프로젝트 전체 구조에 대한 패턴들

### MVVM
- 모바일 앱 개발을 한다면 앱의 확장성과 유지보수의 편의성을 고려해 꼭 아키텍처를 적용하는 것이 필요하다.
- 현재 모바일 앱에 가장 적합한 아키텍처 중 하나가 MVVM
- ms 에서 말한 패턴!
- component에서는 remember를 사용하고 screen에서는 viewModel이 상태관리를 하게 한다.

### ViewModel
- Repository들은 여러 화면에서 다양하게 활용될 수 있게 만들고
- 특정 화면에서 필요한 데이터를 다시 정리해 View에 전달하는 역할을 하는 클래스를 ViewModel 이라 한다.
- 내일 디자인이 바뀌어도 Repository는 변경할 필요가 없어야 한다.
- UI 관련 비즈니스 로직을 처리하는 클래스!
- Repository 들을 활용하여 UI 관련 비즈니스 로직 작성

### MVVM 각 레이어의 역할
#### View
- UI 화면
- ViewModel 의 데이터에 의해 자동 화면 갱신

#### ViewModel
- 화면 비즈니스 로직
- View에서 해야할 동작 정의
- 데이터가 변경되면 View에 알림

#### Model
- 데이터 비즈니스 로직
- DB, 파일, 서버 통신 등 주로 Repository 이하.

### 데이터와 액션의 흐름 관계
- 아키텍처의 핵심은 단방향 의존성 그리고 Action과 Data의 명확하고 일관된 흐름에 있다.

### ViewModel 의 역할
- 모델(Repository) 에서 제공한 데이터를 UI로 표시하기 쉬운 형태로 변환해 주는 역할 (복잡한 로직을 숨겨준다.)
- 화면의 상태를 캡슐화
  - 화면에 표시할 데이터
  - 여러가지 상태 등
- View 에서 발생하는 액션 처리의 캡슐화
- ViewModel은 단지 화면 하나에 대한 로직일 뿐이다. -> 하나의 view 에 하나의 viewModel이 일반적

### viewModel 인스턴스를 얻는 방법
```kotlin
val viewModel = MainViewModel by viewModels() // 레거시 대응!
val viewModel: MainViewModel = viewModel() // compose
```


### 안드로이드가 제공하는 viewModel
- 생명주기를 고려해 UI 관련 데이터를 관리하도록 설계된 클래스
- 화면 회전이나 환경 변경시 데이터를 유지 가능
- ViewModel의 생명주기는 Activity의 일생과 함께 함.

### ViewModel 의존성 주입 방법
```kotlin
class MainViewModel(
    val repository: DataRepository,
) : ViewModel() {

    companion object {

        val Factory: ViewModelProvider.Factory = viewModelFactory {
            initializer {
                val repository = (this[APPLICATION_KEY] as AppApplication).dataRepository
                MainViewModel(repository)
            }
        }
    }
}
```
- ViewModelFactory를 만들어야 한다.
```kotlin
val viewModel: MainViewModel = viewModel(
    factory = MainViewModel.Factory
)
```
- 이렇게 사용~

### Android에서 의존성 주입이 적절한 곳
- Activity: 라이프사이클이 복잡하고 수시로 새로 생성되어 부적절
- Application: 앱에 하나의 Application이 존재한다. 앱이 종료될 때까지 살아있음
- 결론: 의존성 주입에 적합한 곳은 Application

### State를 직접 상태로 가지는 ViewModel이 더 편한가?
- State는 컴포즈 전용이라 범용성을 위해서는 StateFlow 가 낫다.
- 10년 뒤에 State 고고

## 정리
- 현재 모바일에서 가장 유행하는 패턴은 MVVM
- 모든 UI 상태는 ViewModel이 가진다.
- ViewModel은 View에 데이터바인딩을 제공해야 하며 StateFlow or State를 활용하면 쉽게 가능
- StateFlow의 값이 변경되면 관찰자에게 통지
- 이런한 것을 상태관리라고 한다.
- 데이터가 변경되면 화면이 자동으로 다시 그려진다.(recomposition)
- 상태에 따라 자동으로 UI가 적용되니 휴먼 에러가 적어진다.

