# 2025-12-18 TIL

## MVI 패턴
- Model - View - Intent
- Intent : 사용자 액션, 사용자가 UI에서 발생시키는 액션(버튼 클릭, 텍스트 입력 등)
- 복잡한 상태관리에 유용한 패턴

### 사용자 액션 정의
```kotlin
sealed interface HomeAction {
    data class SelectCategory(val category: String) : HomeAction
    data object SearchRecipe : HomeAction
    data class SelectRecipe(val id: Int) : HomeAction
    data class BookmarkRecipe(val id: Int) : HomeAction
}
```
- sealed interface (또는 class) 로 액션 정의

### 사용자 액션을 하나의 메서드에서 모두 처리
- onAction() 에서 모든 액션 처리
- viewModel 의 public 메서드는 onAction() 밖에 없다.

### 화면은 상태와, 사용자 액션 콜백만 가짐
```kotlin
@Composable
private fun RegisterScreen(
    state: RegisterState = RegisterState(),
    onAction: (RegisterAction) -> Unit = {},
) {
    Button(onClick = {onAction(RegisterState.Submit)}) {
        Text(text = "Submit")
    }
}
```
- 액션이 발생하면 콜백으로 돌려준다.

### 정리
- 상태를 모으면 State Holder 패턴
- 콜백을 모으면 MVI 패턴
- 단점
  - 작은 기능에도 Intent, State 등을 정의해야 한다.
- 장점
  - 컴포즈 같은 선언형 UI 와 궁합이 좋다.


## 빌드 변형 - flavor

## flavor
- 비슷한 앱인데 다른 패키지로 빌드하고 싶을 때 Gradle 에서 빌드 환경을 구성할 수 있다.
- 일부 코드나 리소스를 다르게 해 여러 버전 관리 가능


## Stabiliy & Immutability

### Stability (안전성)
- 동일한 입력에 대해 항상 동일한 equals() 결과
- 모든 public 프로퍼티가 stable
- 스레드 안전한 상태 변경

### Immutabiliy (불변성)
```kotlin
// 불변 데이터 클래스(안전)
data class User(
    val id: Int,
    val name: String,
    val email: String,
)

// 가변 클래스(불안전)
class MutableUser {
    var id: Int = 0
    var name: String = ""
    var email: String = ""
}
```


### Unstable 한 경우
- var 프로퍼티가 있는 클래스
- mutable 컬렉션 (List, Set 으로 선언하면 컴파일러는 불안전한 타입으로 봄)
- Any, Object 타입
- 제네릭 타입 파라미터(기본적으로)
```kotlin
data class Recipe(
    val category: String,
    // .....
    val ingredients: List<Ingredient>
)
```
- 이 데이터 클래스의 List 는 불변이지만 불안정하다.
-> Jetbrains 에서 제공하는 불변 컬렉션 라이브러리 활용해서 바꿀 수 있다.
`implementation("org.jetbrains.kotlinx:kotlinx-collections-immutable:$version")`


### 자동으로 Stable 한 타입
- 기본 타입 (Int, String, Boolean)
- Immutable 컬렉션 
- data class (불변 프로퍼티만 있는 경우)
- sealed class/interface
- enum class


### @Immutable 로 불변을 보증
- 경우에 따라서는 List 를 유지하고 @Immutable 어노테이션으로 불변임을 보증하는 것이 좋을 수도 있다.
  - 자바 호환성
  - 기존 코드의 수정포인트가 너무 많음 등등의 이유
- 단 개발자가 스스로 책임을 져야 한다.


### 스마트 리컴포지션
```kotlin
fun ItemList(items: List<Item>) {
    LazyColumn {
        items(items) { item ->
            // item이 stable 하면 필요할 때만 리컴포지션
            ItemRow(item)
        }
    }
}
```

### 권장 사항
- 가능한 불변 데이터 사용
- data class 활용
- @Stable, @Immutable 어노테이션 적절히 사용
- mutable 상태는 remember 로 관리

