# DI 의존성 주입

## 의존성 주입 개념

의존성 주입(Dependency Injection, DI)은 객체가 자신의 의존성을 직접 생성하지 않고 외부에서 제공받는 소프트웨어 디자인 패턴이다.
"누가 준비해서 나에게 넣어줘!"

## 의존성 역전 원칙(Dependency Inversion Principle, DIP)

- 의존성 주입(DI)은 소프트웨어 디자인 원칙 중 "의존성 역전 원칙"을 구현하는 핵심임

- DIP의 핵심
  - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 되며, 추상화에 의존해야 한다.
  - 추상화는 구체적인 구현 세부 사항에 의존해서는 안 된다.

- 기대 효과
  - ViewModel이 구체적인 RepositoryImpl 클래스가 아닌, 인터페이스에 의존하게 되어 결합도가 낮아짐.
  - 쉽게 다른 구현체로 교체할 수 있고 테스트가 용이해 짐.

## 의존성 주입의 장점

- 테스트 용이성: 모의 객체(mock)를 주입하여 단위 테스트 가능
- 유연성: 동일한 인터페이스를 구현한 다양한 구현체로 쉽게 교체 가능
- 결합도 감소: 컴포넌트 간 직접적인 의존성 제거
- 관심사 분리: 객체 생성과 사용의 책임 분리

## 의존성 주입 예제: ViewModel 코드 비교

이론적인 개념을 실제 안드로이드 코드에 적용해 보겠습니다. `ViewModel`이 `UseCase`를, `UseCase`가 `Repository`를 필요로 하는 일반적인 상황을 가정합니다.

### 1. DI가 없는 경우 (나쁜 예)

모든 객체를 내부에서 직접 생성합니다. 각 클래스가 특정 구현체에 강하게 결합(의존)되어 있습니다.

```kotlin
// ViewModel이 UseCase를 직접 생성
class SavedRecipesViewModel : ViewModel() {
    // 😫 내부에서 직접 의존성을 생성하고 있습니다.
    private val getSavedRecipesUseCase = GetSavedRecipesUseCase()

    fun loadRecipes() {
        // ...
    }
}

// UseCase가 Repository를 직접 생성
class GetSavedRecipesUseCase {
    // 😫 내부에서 직접 의존성을 생성하고 있습니다.
    private val recipeRepository = RecipeRepositoryImpl()

    suspend operator fun invoke(): List<Recipe> {
        return recipeRepository.getRecipes()
    }
}

// Repository 구현체
class RecipeRepositoryImpl : RecipeRepository {
    // ...
}
```

**문제점:**
- **테스트 불가:** `SavedRecipesViewModel`을 테스트하려면 `GetSavedRecipesUseCase`와 `RecipeRepositoryImpl`의 실제 인스턴스가 필요합니다. `RecipeRepositoryImpl`이 네트워크 통신을 한다면, 테스트는 느려지고 외부 요인에 영향을 받게 됩니다.
- **유연성 부족:** `RecipeRepositoryImpl`을 다른 구현체(예: `TestRecipeRepositoryImpl`)로 바꾸려면 `GetSavedRecipesUseCase`의 코드를 직접 수정해야 합니다.

### 2. 수동 의존성 주입 (좋은 예)

객체 생성의 책임을 외부로 옮기고, 생성자를 통해 의존성을 '주입'해 줍니다.

```kotlin
// ViewModel은 UseCase를 외부에서 주입받습니다.
// 이제 SavedRecipesViewModel은 GetSavedRecipesUseCase가 어떻게 만들어지는지 신경쓰지 않습니다.
class SavedRecipesViewModel(
    private val getSavedRecipesUseCase: GetSavedRecipesUseCase, // 👍 외부에서 주입
) : ViewModel() {
    fun loadRecipes() {
        // ...
    }
}

// UseCase는 Repository '인터페이스'를 외부에서 주입받습니다.
class GetSavedRecipesUseCase(
    private val recipeRepository: RecipeRepository // 👍 외부에서 주입 (구현체가 아닌 인터페이스)
) {
    suspend operator fun invoke(): List<Recipe> {
        return recipeRepository.getRecipes()
    }
}

// -- 객체를 생성하고 주입하는 외부 공간 (ex: Activity, Fragment) --
// 실제 앱에서는 Hilt나 Koin같은 라이브러리가 이 역할을 대신해줍니다.
val repository: RecipeRepository = RecipeRepositoryImpl()
val useCase = GetSavedRecipesUseCase(repository)
val viewModel = SavedRecipesViewModel(useCase)
```

**개선된 점:**
- **테스트 용이성:** `SavedRecipesViewModel` 테스트 시, 가짜(Mock) `GetSavedRecipesUseCase`를 쉽게 주입할 수 있습니다.
- **유연성 향상:** `GetSavedRecipesUseCase`의 코드 수정 없이 `RecipeRepositoryImpl`이 아닌 다른 `RecipeRepository` 구현체를 주입할 수 있습니다.
- **의존성 역전:** `GetSavedRecipesUseCase`는 구체적인 `RecipeRepositoryImpl`가 아닌, 추상적인 `RecipeRepository` 인터페이스에 의존하게 됩니다. (DIP 원칙 준수)

## 의존성 등록 방식의 차이

- Singleton
  - 앱 시작시 1번만 생성됨
  - 예시 : Repository, DataSource, UseCase

- Factory
  - 필요할 때마다 새로 생성
  - 예시 : ViewModel

## ViewModel은 왜 Factory 인가

- 상태가 화면마다 다르기 때문에
  - ViewModel 은 화면 상태(UI State)를 관리
  - 각 화면마다 독립된 상태가 필요

- 의도하지 않은 상태 공유를 방지하기 위해
  - Singleton 으로 만들면 앱 전체에서 하나의 ViewModel만 사용됨
  - 상태가 섞이거나 꼬일 수 있음
  - A 화면에서 값이 바뀌면 B 화면에도 반영되서 버그 발생

## Repository 등은 왜 Singleton 인가

- 대부분 상태를 갖지 않는 기능 클래스이기 때문에
- 같은 기능은 계속 재사용하면 효율적
- 메모리도 아끼고, 빠르고 안정적

## Android 에서의 의존성 주입 라이브러리

- Dagger
  - 레거시, Java용

- Hilt
  - (Android 전용 - 대거 상위호환, Java 어노테이션 활용 - 컴파일 타임 안전, Google 주도)
  - 매직이 많음
  - KMP 대응
  - 취업하려면 써야 함

### Hilt 예제

Hilt는 어노테이션을 사용하여 보일러플레이트를 줄이고, 컴파일 시간에 의존성 그래프를 검증합니다.

```kotlin
// Module: 의존성을 제공하는 방법을 Hilt에 알립니다.
@Module
@InstallIn(SingletonComponent::class) // 앱 전역에서 사용될 의존성
object AppModule {

    // Repository 인터페이스에 대한 구현체를 제공합니다.
    @Provides
    @Singleton // 앱 전체에서 단 하나의 인스턴스만 사용하도록 지정
    fun provideRecipeRepository(dataSource: RecipeDataSource): RecipeRepository {
        return RecipeRepositoryImpl(dataSource)
    }

    // UseCase를 제공합니다. Repository는 위에서 제공받아 주입합니다.
    @Provides
    @Singleton
    fun provideGetSavedRecipesUseCase(repository: RecipeRepository): GetSavedRecipesUseCase {
        return GetSavedRecipesUseCase(repository)
    }

    @Provides
    @Singleton
    fun provideRecipeDataSource(): RecipeDataSource {
        return RecipeDataSourceImpl()
    }
}

// ViewModel: 생성자에 @Inject를 추가하고 @HiltViewModel 어노테이션을 붙입니다.
@HiltViewModel
class SavedRecipesViewModel @Inject constructor(
    private val getSavedRecipesUseCase: GetSavedRecipesUseCase // Hilt가 알아서 주입해줍니다.
) : ViewModel() {
    // ...
}

// Activity/Fragment: @AndroidEntryPoint 어노테이션을 추가하고 ViewModel을 주입받습니다.
@AndroidEntryPoint
class MyActivity : AppCompatActivity() {

    // by viewModels()를 사용하면 Hilt가 ViewModel 인스턴스를 생성하고 제공합니다.
    private val viewModel: SavedRecipesViewModel by viewModels()

    // ...
}
```

- Koin
  - (코틀린 전용 - 런타임 주입)
  - 직관적
  - 근본에 가까움
  - KMP 대응

### Koin 예제

Koin은 코틀린 DSL(Domain-Specific Language)을 사용하여 런타임에 의존성을 주입합니다. 코드가 더 직관적입니다.

```kotlin
// Module: 코틀린 DSL로 의존성을 정의합니다.
val appModule = module {

    // Repository를 Singleton으로 정의합니다. get()은 다른 의존성을 자동으로 주입합니다.
    single<RecipeRepository> { RecipeRepositoryImpl(get()) }

    // UseCase를 Singleton으로 정의합니다.
    single { GetSavedRecipesUseCase(get()) }

    // DataSource를 Singleton으로 정의합니다.
    single<RecipeDataSource> { RecipeDataSourceImpl() }

    // ViewModel은 매번 새로운 인스턴스를 생성하는 factory로 정의할 수 있지만,
    // Koin은 viewModel 키워드를 제공하여 ViewModel의 생명주기를 더 쉽게 관리하게 해줍니다.
    viewModel { SavedRecipesViewModel(get()) }
}

// Application Class: Koin을 시작합니다.
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidContext(this@MyApplication)
            modules(appModule) // 정의한 모듈을 등록합니다.
        }
    }
}


// Activity/Fragment: by viewModel() 델리게이트로 ViewModel을 주입받습니다.
class MyActivity : AppCompatActivity() {

    // Koin의 by viewModel()을 사용하여 ViewModel 인스턴스를 주입받습니다.
    private val viewModel: SavedRecipesViewModel by viewModel()

    // ...
}
```
