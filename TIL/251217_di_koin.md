## Koin

### Koin 개념

> 런타임 기반 (Service Locator 스타일)의 DI 프레임워크)

```kotlin
 val viewModelModule = module {
    viewModel {
        HomeViewModel(
            recipeRepository = get(),
            bookmarkRepository = get(),
            toggleBookmarkUseCase = get()
        )
    }
}
 ```

- get ?
    - “이 타입의 의존성을 컨테이너에서 찾아 달라”

- 컴파일 타임 코드 생성 ❌
- Annotation ❌
- Kotlin DSL (Domain Specific Language)로 객체 생성 규칙을 정의
    - Kotlin 문법을 이용해서 설정/구성 코드를 ‘코드처럼’ 작성하게 만든 방식
- 컨테이너가 객체 생성 책임을 가짐
    - 객체를 대신 생성·보관·제공하는 중앙 관리소
    - 컨테이너 안쓰면
    ```kotlin
    val repository = RecipeRepositoryImpl(
    MockRecipeDataSourceImpl(),
    MockIngredientDataSourceImpl()
    )
    val viewModel = HomeViewModel(repository)
    ```
      - 객체 생성 책임이 여기저기 흩어짐
      - 교체/테스트 어려움
      - 의존성 증가할수록 복잡도 폭증

    - 컨테이너 쓰면
    ```kotlin
    val viewModel: HomeViewModel = koinViewModel()
    ```
      - “누가 만들었는지” 몰라도 됨 
      - 필요한 타입만 요청

#### 요소

| 개념             | 역할               |
|----------------|------------------|
| `module {}`    | 객체 생성 규칙 정의      |
| `single {}`    | 앱 전체에서 하나의 인스턴스  |
| `factory {}`   | 요청할 때마다 새 인스턴스   |
| `viewModel {}` | ViewModel 전용 스코프 |
| `startKoin {}` | DI 컨테이너 초기화      |

### 기존 ViewModel Factory 방식

#### 기존 구조 (Koin 도입 전)

```kotlin
class HomeViewModel(
    private val repository: RecipeRepository
) : ViewModel()
```

- ViewModel이 의존성을 가지면 기본 viewModel()로 생성 불가
    - 그래서 직접 Factory를 만들어야 했음

#### 문제점

| 문제                | 설명                               |
|-------------------|----------------------------------|
| 생성 책임 분산          | ViewModel마다 Factory 필요           |
| 보일러플레이트           | 반복 코드 과다                         |
| Context 의존 위험     | Application 꺼내오는 패턴 발생           |
| Navigation 변경에 취약 | Navigation3에서 APPLICATION_KEY 문제 |
| 테스트 어려움           | Factory 재구성 필요                   |

### Koin 도입 이후

#### 생성 책임 이동

- Before
    - ViewModel 생성 책임 → UI / Factory

- After
    - ViewModel 생성 책임 → DI 컨테이너 (Koin)
    ```kotlin
    val viewModel: HomeViewModel = koinViewModel()
    ```
    - UI는 “어떻게 생성되는지” 몰라도 됨
    - “무엇을 쓰는지”만 알면 됨

#### Factory 제거

- Before

```kotlin
class HomeViewModel : ViewModel() {
    companion object {
        fun Factory(application: AppApplication): ViewModelProvider.Factory =
            viewModelFactory {
                initializer {
                    HomeViewModel(
                        recipeRepository = application.recipeRepository,
                        bookmarkRepository = application.bookmarkRepository,
                        toggleBookmarkUseCase = application.toggleBookmarkUseCase
                    )
                }
            }
    }
}
```

- After
    ```kotlin
    viewModel { HomeViewModel(get(), get(), get()) }
    ```
    - Factory 제거
    - ViewModel 생성 책임을 DI 컨테이너(Koin)로 이전
    - Application을 통해 의존성을 조회하던 구조 제거
    - Context에 독립적인 ViewModel 구조로 개선

#### 비교

| 항목             | 기존 Factory     | Koin        |
|----------------|----------------|-------------|
| 생성 시점          | UI에서 직접        | DI 컨테이너     |
| Factory 클래스    | 필요             | 불필요         |
| 보일러플레이트        | 많음             | 적음          |
| Application 의존 | 자주 발생          | 없음          |
| Navigation3 대응 | 까다로움           | 자연스러움       |
| 테스트            | Factory 재구성    | Module 교체   |
| 확장성            | ViewModel마다 추가 | Module에만 추가 |

### 의존성 주입 원칙

> 클래스는 자신이 무엇을 필요로 하는지만 드러내고, 그것을 어떻게 얻는지는 외부에 맡긴다

- ❌ 클래스 내부에서 의존성을 “찾지 말고”
- ✅ 생성자를 통해 “주입받아야” 한다
    ```kotlin
    class HomeViewModel(
        private val recipeRepository: RecipeRepository,
        private val bookmarkRepository: BookmarkRepository
    )
    ```

#### 서비스 로케이터?

> 객체가 스스로 컨테이너에게 필요한 의존성을 요청(get) 하는 방식

- 안 좋은 예: 클래스 내부에서 직접 Service Locator 사용
    ```kotlin
    class HomeViewModel : ViewModel() {
    
        private val recipeRepository: RecipeRepository =
            ServiceLocator.get()
    
        private val bookmarkRepository: BookmarkRepository =
            ServiceLocator.get()
    }
    ```
- 또는 Koin을 잘못 쓴 경우
    ```kotlin
    class HomeViewModel : ViewModel() {
    
        private val recipeRepository: RecipeRepository =
            getKoin().get()
    }
    ```

#### 문제가 되는 이유

- 클래스 의존성이 숨겨짐

```kotlin
class HomeViewModel : ViewModel() {
    // 생성자에는 아무것도 없음
}
```

- 겉보기엔 의존성 없어 보임
- 실제로는 내부에서 여러 객체를 가져옴
    - 코드만 봐서는 이 클래스의 책임을 파악하기 어려움

- 테스트가 어려워짐

#### 올바르게 사용

- 최상단에서만 get() 사용 (구성 단계)
    ```kotlin
    val viewModelModule = module {
        viewModel {
            HomeViewModel(
                recipeRepository = get(),
                bookmarkRepository = get(),
                toggleBookmarkUseCase = get()
            )
        }
    }
    ```
    - 여기서의 get()은:
        - 객체 생성 규칙을 선언하는 단계
        - 비즈니스 로직 ❌
        - 앱 구성 코드 ⭕
- 실제 클래스는 생성자 주입만 사용
    ```kotlin
    class HomeViewModel(
        private val recipeRepository: RecipeRepository,
        private val bookmarkRepository: BookmarkRepository,
        private val toggleBookmarkUseCase: ToggleBookmarkUseCase
    ) : ViewModel()
    ```
    - get() 없음
        - Koin 모름
        - DI 프레임워크와 완전히 분리
- UI에서는 “요청만”
    ```kotlin
    @Composable
    fun HomeRoot(
        viewModel: HomeViewModel = koinViewModel()
    ) {
        val state by viewModel.state.collectAsStateWithLifecycle()
    }
    ```
    - ViewModel 생성 방식 모름
        - 교체 가능
        - 테스트/프리뷰 확장 용이