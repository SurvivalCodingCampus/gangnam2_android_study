
# Android 테스트의 모든 것: 단위, 통합, UI 테스트

Android 앱의 안정성과 품질을 보장하기 위해 테스트는 필수적입니다. 이 문서에서는 세 가지 주요 테스트 유형인 단위 테스트(Unit Tests), 통합 테스트(Integration Tests), UI 테스트(UI Tests)에 대해 초보자부터 전문가까지 모두가 참고할 수 있도록 상세히 설명합니다.

---

## 1. Unit Tests (단위 테스트)

단위 테스트는 가장 작은 코드 단위(함수, 클래스, 메서드 등)를 개별적으로 검증하는 테스트입니다. 외부 의존성을 제거하고 독립된 환경에서 진행되므로 가장 빠르고 안정적입니다.

### 주요 특징

- **신속한 실행**: 테스트 실행 속도가 빨라 개발 과정에서 수시로 실행하며 문제를 조기에 발견할 수 있습니다.
- **격리된 환경**: 다른 컴포넌트와의 의존성을 없애기 위해 **Mock**이나 **Stub**과 같은 테스트 더블(Test Double)을 사용합니다.
- **TDD (Test-Driven Development)**: 단위 테스트는 테스트 주도 개발의 핵심 요소입니다.

### Mock vs. Stub

- **Stub**: 미리 정해진 값을 반환하는 가짜 객체입니다. 주로 상태(State)를 검증할 때 사용됩니다.
- **Mock**: 호출 여부나 호출 횟수 등 행위(Behavior)를 검증하는 데 중점을 둔 객체입니다. Stub의 기능을 포함합니다.

### 예제: ViewModel 단위 테스트 (JUnit5 & Mockito)

`SavedRecipesViewModel`의 로직이 올바르게 동작하는지 단위 테스트를 통해 검증해 보겠습니다. `getSavedRecipesUseCase`를 Mock 객체로 만들어 ViewModel의 행위를 테스트합니다.

```kotlin
import com.survivalcoding.gangnam2kiandroidstudy.domain.model.Recipe
import com.survivalcoding.gangnam2kiandroidstudy.domain.usercase.GetSavedRecipesUseCase
import com.survivalcoding.gangnam2kiandroidstudy.presentation.savedrecipes.SavedRecipesViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever

@ExperimentalCoroutinesApi
class SavedRecipesViewModelTest {

    // 테스트할 ViewModel
    private lateinit var viewModel: SavedRecipesViewModel

    // Mock 객체로 만들 UseCase
    private val getSavedRecipesUseCase: GetSavedRecipesUseCase = mock()

    // 코루틴 테스트를 위한 Dispatcher
    private val testDispatcher = StandardTestDispatcher()

    @BeforeEach
    fun setUp() {
        // 테스트 실행 전, Main Dispatcher를 테스트용 Dispatcher로 교체
        Dispatchers.setMain(testDispatcher)
        // ViewModel 인스턴스 생성
        viewModel = SavedRecipesViewModel(getSavedRecipesUseCase)
    }

    @AfterEach
    fun tearDown() {
        // 테스트 종료 후, Main Dispatcher를 원래대로 복원
        Dispatchers.resetMain()
    }

    @Test
    @DisplayName("ViewModel 초기화 시 저장된 레시피 목록을 성공적으로 불러오는지 테스트")
    fun `viewModel init should load saved recipes successfully`() = runTest {
        // Given: UseCase가 반환할 가짜 레시피 목록 준비
        val fakeRecipes = listOf(
            Recipe(id = 1, title = "레시피 1", image = ""),
            Recipe(id = 2, title = "레시피 2", image = "")
        )
        // UseCase의 invoke()가 호출되면 fakeRecipes를 반환하도록 설정
        whenever(getSavedRecipesUseCase.invoke()).thenReturn(fakeRecipes)

        // When: ViewModel이 생성되면 init 블록이 실행됨
        // (setUp에서 이미 생성되었으므로 별도 호출 필요 없음)

        // Advance a bit to allow the coroutine in init to start
        testDispatcher.scheduler.advanceUntilIdle()

        // Then: ViewModel의 uiState가 예상대로 업데이트되었는지 검증
        val uiState = viewModel.uiState.value
        assertEquals(false, uiState.isLoading, "로딩 상태가 false여야 합니다.")
        assertEquals(2, uiState.recipes.size, "레시피 목록의 개수가 2개여야 합니다.")
        assertEquals("레시피 1", uiState.recipes[0].title, "첫 번째 레시피의 제목이 일치해야 합니다.")
    }
}
```

---

## 2. Integration Tests (통합 테스트)

통합 테스트는 두 개 이상의 컴포넌트가 함께 동작할 때 발생하는 문제를 검증합니다. 예를 들어, UI 컨트롤러, ViewModel, 데이터베이스(Room) 간의 상호작용을 테스트할 수 있습니다.

### 주요 특징

- **상호작용 검증**: 컴포넌트 간의 데이터 흐름과 로직이 올바르게 동작하는지 확인합니다.
- **준-실제 환경**: 단위 테스트보다 실제 환경에 가깝게 테스트하지만, 네트워크 호출 등 외부 시스템은 Mocking 하기도 합니다.
- **AndroidX Test 라이브러리**: `ActivityScenario`, `HiltAndroidTest` 등 AndroidX Test 라이브러리를 활용하여 테스트 환경을 구성합니다.

### 예제: Room 데이터베이스 통합 테스트

`RecipeDao`를 통해 데이터를 저장하고, `SavedRecipesViewModel`이 이 데이터를 올바르게 불러오는지 통합 테스트로 검증합니다.

```kotlin
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.survivalcoding.gangnam2kiandroidstudy.data.data_source.local.AppDatabase
import com.survivalcoding.gangnam2kiandroidstudy.data.data_source.local.dao.RecipeDao
import com.survivalcoding.gangnam2kiandroidstudy.data.repository.RecipeRepositoryImpl
import com.survivalcoding.gangnam2kiandroidstudy.domain.usercase.GetSavedRecipesUseCase
import com.survivalcoding.gangnam2kiandroidstudy.presentation.savedrecipes.SavedRecipesViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
class SavedRecipesIntegrationTest {

    // LiveData 테스트를 위한 규칙
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    private lateinit var database: AppDatabase
    private lateinit var recipeDao: RecipeDao
    private lateinit var viewModel: SavedRecipesViewModel

    @Before
    fun setup() {
        // Main Dispatcher 설정
        Dispatchers.setMain(Dispatchers.Unconfined)

        // 인메모리 Room 데이터베이스 생성 (테스트용)
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            AppDatabase::class.java
        ).allowMainThreadQueries().build()

        recipeDao = database.recipeDao()

        // 실제 Repository와 UseCase, ViewModel 연결
        val recipeRepository = RecipeRepositoryImpl(recipeDao)
        val getSavedRecipesUseCase = GetSavedRecipesUseCase(recipeRepository)
        viewModel = SavedRecipesViewModel(getSavedRecipesUseCase)
    }

    @After
    fun tearDown() {
        database.close()
    }

    @Test
    fun `데이터베이스에 저장된 레시피를 ViewModel이 올바르게 불러오는지 테스트`() = runTest {
        // Given: DB에 테스트 데이터 삽입
        val recipeEntity = RecipeEntity(id = 1, title = "테스트 레시피")
        recipeDao.insert(recipeEntity)

        // When: ViewModel이 초기화되면서 데이터를 로드함 (setup에서 이미 수행됨)
        
        // Then: ViewModel의 상태가 DB 데이터와 일치하는지 확인
        val recipes = viewModel.uiState.value.recipes
        assertEquals(1, recipes.size)
        assertEquals("테스트 레시피", recipes[0].title)
    }
}
```

---

## 3. UI Tests (UI 테스트)

UI 테스트는 사용자 관점에서 앱의 흐름을 테스트합니다. 실제 사용자가 앱을 사용하는 것처럼 화면의 요소를 찾고, 클릭하고, 텍스트를 입력하는 등의 상호작용을 시뮬레이션합니다.

### 주요 특징

- **E2E(End-to-End) 테스트**: 사용자의 전체 시나리오를 처음부터 끝까지 테스트합니다.
- **신뢰성 확보**: 실제와 가장 유사한 환경에서 테스트하므로 앱의 최종 품질에 대한 신뢰도가 높습니다.
- **실행 속도**: 실제 기기나 에뮬레이터에서 실행되므로 속도가 가장 느립니다.

### Jetpack Compose UI 테스트

Jetpack Compose에서는 `ComposeTestRule`을 사용하여 UI 테스트를 작성합니다. Semantics Tree를 기반으로 특정 컴포저블을 찾고, 상호작용을 수행하며, 상태를 검증할 수 있습니다.

### 예제: Composable UI 테스트

`SavedRecipesScreen`에 "Saved recipes"라는 텍스트가 올바르게 표시되는지 확인하는 간단한 UI 테스트입니다.

```kotlin
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.survivalcoding.gangnam2kiandroidstudy.presentation.savedrecipes.SavedRecipesScreen
import com.survivalcoding.gangnam2kiandroidstudy.presentation.savedrecipes.SavedRecipesState
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class SavedRecipesScreenTest {

    // Compose UI 테스트를 위한 규칙
    @get:Rule
    val composeTestRule = createComposeRule()

    @Test
    fun `SavedRecipesScreen에 제목이 올바르게 표시되는지 테스트`() {
        // Given: 테스트할 UI 상태 정의
        val testState = SavedRecipesState(isLoading = false, recipes = emptyList())

        // When: 테스트할 Composable을 화면에 렌더링
        composeTestRule.setContent {
            SavedRecipesScreen(uiState = testState)
        }

        // Then: "Saved recipes" 텍스트를 가진 노드를 찾고, 화면에 표시되는지 검증
        composeTestRule.onNodeWithText("Saved recipes").assertIsDisplayed()
    }
}
```

---

### 결론: 테스트 피라미드

이상적인 테스트 전략은 **테스트 피라미드**를 따릅니다.

- **Unit Tests (가장 많이)**: 빠르고 안정적이므로 가장 많은 수를 차지해야 합니다.
- **Integration Tests (중간)**: 컴포넌트 간의 주요 상호작용을 검증합니다.
- **UI Tests (가장 적게)**: 실행 비용이 높으므로 핵심적인 사용자 시나리오만 검증합니다.

이 세 가지 테스트를 균형 있게 작성하여 버그를 조기에 발견하고, 리팩토링에 대한 자신감을 얻으며, 항상 안정적인 앱을 제공할 수 있습니다.
